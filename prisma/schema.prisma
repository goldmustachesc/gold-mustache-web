// Prisma schema for Gold Mustache - Supabase Auth integration

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Profile {
  id        String   @id @default(uuid())
  userId    String   @unique @map("user_id")
  fullName  String?  @map("full_name")
  avatarUrl String?  @map("avatar_url")
  phone     String?
  role      UserRole @default(CLIENT)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  appointments Appointment[]

  @@map("profiles")
}

enum UserRole {
  CLIENT
  BARBER
  ADMIN
}

// Guest clients who book without creating an account
model GuestClient {
  id          String   @id @default(uuid())
  fullName    String   @map("full_name")
  phone       String   @unique
  accessToken String?  @unique @map("access_token")
  createdAt   DateTime @default(now()) @map("created_at")

  appointments Appointment[]

  @@map("guest_clients")
}

// ============================================
// Booking System Models
// ============================================

model Service {
  id          String   @id @default(uuid())
  slug        String   @unique
  name        String
  description String?
  duration    Int      // em minutos
  price       Decimal  @db.Decimal(10, 2)
  active      Boolean  @default(true)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  appointments Appointment[]
  barbers      BarberService[]

  @@map("services")
}

model Barber {
  id        String   @id @default(uuid())
  userId    String   @unique @map("user_id")
  name      String
  avatarUrl String?  @map("avatar_url")
  active    Boolean  @default(true)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  appointments Appointment[]
  services     BarberService[]
  workingHours WorkingHours[]
  absences     BarberAbsence[]

  @@map("barbers")
}

model BarberService {
  barberId  String @map("barber_id")
  serviceId String @map("service_id")

  barber  Barber  @relation(fields: [barberId], references: [id], onDelete: Cascade)
  service Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@id([barberId, serviceId])
  @@map("barber_services")
}

model WorkingHours {
  id         String  @id @default(uuid())
  barberId   String  @map("barber_id")
  dayOfWeek  Int     @map("day_of_week") // 0=Sunday, 6=Saturday
  startTime  String  @map("start_time") // "09:00"
  endTime    String  @map("end_time") // "18:00"
  breakStart String? @map("break_start")
  breakEnd   String? @map("break_end")

  barber Barber @relation(fields: [barberId], references: [id], onDelete: Cascade)

  @@unique([barberId, dayOfWeek])
  @@map("working_hours")
}

// ============================================
// Shop-wide hours and closures
// ============================================

model ShopHours {
  id         String  @id @default(uuid())
  dayOfWeek  Int     @unique @map("day_of_week") // 0=Sunday, 6=Saturday
  isOpen     Boolean @default(true) @map("is_open")
  startTime  String? @map("start_time") // "09:00" (nullable when closed)
  endTime    String? @map("end_time") // "18:00" (nullable when closed)
  breakStart String? @map("break_start")
  breakEnd   String? @map("break_end")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("shop_hours")
}

// A closure for a specific date. If start/end are null => closed all day.
model ShopClosure {
  id        String   @id @default(uuid())
  date      DateTime @db.Date
  startTime String?  @map("start_time")
  endTime   String?  @map("end_time")
  reason    String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([date])
  @@map("shop_closures")
}

// ============================================
// Barber absences
// ============================================

model BarberAbsence {
  id        String   @id @default(uuid())
  barberId  String   @map("barber_id")
  date      DateTime @db.Date
  startTime String?  @map("start_time")
  endTime   String?  @map("end_time")
  reason    String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  barber Barber @relation(fields: [barberId], references: [id], onDelete: Cascade)

  @@index([barberId, date])
  @@map("barber_absences")
}

model Appointment {
  id            String            @id @default(uuid())
  clientId      String?           @map("client_id") // Optional - for registered users
  guestClientId String?           @map("guest_client_id") // Optional - for guest bookings
  barberId      String            @map("barber_id")
  serviceId     String            @map("service_id")
  date          DateTime          @db.Date
  startTime     String            @map("start_time") // "10:30"
  endTime       String            @map("end_time") // "11:00"
  status        AppointmentStatus @default(CONFIRMED)
  cancelReason  String?           @map("cancel_reason")
  createdAt     DateTime          @default(now()) @map("created_at")
  updatedAt     DateTime          @updatedAt @map("updated_at")

  client      Profile?     @relation(fields: [clientId], references: [id])
  guestClient GuestClient? @relation(fields: [guestClientId], references: [id])
  barber      Barber       @relation(fields: [barberId], references: [id])
  service     Service      @relation(fields: [serviceId], references: [id])

  // IMPORTANT:
  // We intentionally do NOT keep a global UNIQUE constraint here, because cancelled
  // appointments must not permanently block the same slot from being rebooked.
  // Uniqueness for active bookings is enforced via a PARTIAL unique index in SQL
  // (status = 'CONFIRMED') plus an advisory-lock + overlap-check in `src/services/booking.ts`.
  @@index([barberId, date, startTime])
  @@map("appointments")
}

enum AppointmentStatus {
  CONFIRMED
  CANCELLED_BY_CLIENT
  CANCELLED_BY_BARBER
  COMPLETED
  NO_SHOW
}

model Notification {
  id        String           @id @default(uuid())
  userId    String           @map("user_id")
  type      NotificationType
  title     String
  message   String
  data      Json? // metadata adicional
  read      Boolean          @default(false)
  createdAt DateTime         @default(now()) @map("created_at")

  @@map("notifications")
}

enum NotificationType {
  APPOINTMENT_CONFIRMED
  APPOINTMENT_CANCELLED
  APPOINTMENT_REMINDER
}
