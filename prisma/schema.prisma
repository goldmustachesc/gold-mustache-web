// Prisma schema for Gold Mustache - Supabase Auth integration

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Profile {
  id             String   @id @default(uuid())
  userId         String   @unique @map("user_id")
  fullName       String?  @map("full_name")
  avatarUrl      String?  @map("avatar_url")
  phone          String?
  // Address fields
  street         String?
  number         String?
  complement     String?
  neighborhood   String?
  city           String?
  state          String?
  zipCode        String?  @map("zip_code")
  // Account verification
  emailVerified  Boolean  @default(false) @map("email_verified")
  role           UserRole @default(CLIENT)
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  appointments Appointment[]

  @@map("profiles")
}

enum UserRole {
  CLIENT
  BARBER
  ADMIN
}

// Guest clients who book without creating an account
model GuestClient {
  id          String   @id @default(uuid())
  fullName    String   @map("full_name")
  phone       String   @unique
  accessToken String?  @unique @map("access_token")
  createdAt   DateTime @default(now()) @map("created_at")

  appointments Appointment[]

  @@map("guest_clients")
}

// ============================================
// Booking System Models
// ============================================

model Service {
  id          String   @id @default(uuid())
  slug        String   @unique
  name        String
  description String?
  duration    Int      // em minutos
  price       Decimal  @db.Decimal(10, 2)
  active      Boolean  @default(true)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  appointments Appointment[]
  barbers      BarberService[]

  @@map("services")
}

model Barber {
  id        String   @id @default(uuid())
  userId    String   @unique @map("user_id")
  name      String
  avatarUrl String?  @map("avatar_url")
  active    Boolean  @default(true)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  appointments Appointment[]
  services     BarberService[]
  workingHours WorkingHours[]
  absences     BarberAbsence[]

  @@map("barbers")
}

model BarberService {
  barberId  String @map("barber_id")
  serviceId String @map("service_id")

  barber  Barber  @relation(fields: [barberId], references: [id], onDelete: Cascade)
  service Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@id([barberId, serviceId])
  @@map("barber_services")
}

model WorkingHours {
  id         String  @id @default(uuid())
  barberId   String  @map("barber_id")
  dayOfWeek  Int     @map("day_of_week") // 0=Sunday, 6=Saturday
  startTime  String  @map("start_time") // "09:00"
  endTime    String  @map("end_time") // "18:00"
  breakStart String? @map("break_start")
  breakEnd   String? @map("break_end")

  barber Barber @relation(fields: [barberId], references: [id], onDelete: Cascade)

  @@unique([barberId, dayOfWeek])
  @@map("working_hours")
}

// ============================================
// Shop-wide hours and closures
// ============================================

model ShopHours {
  id         String  @id @default(uuid())
  dayOfWeek  Int     @unique @map("day_of_week") // 0=Sunday, 6=Saturday
  isOpen     Boolean @default(true) @map("is_open")
  startTime  String? @map("start_time") // "09:00" (nullable when closed)
  endTime    String? @map("end_time") // "18:00" (nullable when closed)
  breakStart String? @map("break_start")
  breakEnd   String? @map("break_end")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("shop_hours")
}

// A closure for a specific date. If start/end are null => closed all day.
model ShopClosure {
  id        String   @id @default(uuid())
  date      DateTime @db.Date
  startTime String?  @map("start_time")
  endTime   String?  @map("end_time")
  reason    String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([date])
  @@map("shop_closures")
}

// ============================================
// Barber absences
// ============================================

model BarberAbsence {
  id        String   @id @default(uuid())
  barberId  String   @map("barber_id")
  date      DateTime @db.Date
  startTime String?  @map("start_time")
  endTime   String?  @map("end_time")
  reason    String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  barber Barber @relation(fields: [barberId], references: [id], onDelete: Cascade)

  @@index([barberId, date])
  @@map("barber_absences")
}

model Appointment {
  id            String            @id @default(uuid())
  clientId      String?           @map("client_id") // Optional - for registered users
  guestClientId String?           @map("guest_client_id") // Optional - for guest bookings
  barberId      String            @map("barber_id")
  serviceId     String            @map("service_id")
  date          DateTime          @db.Date
  startTime     String            @map("start_time") // "10:30"
  endTime       String            @map("end_time") // "11:00"
  status        AppointmentStatus @default(CONFIRMED)
  cancelReason  String?           @map("cancel_reason")
  createdAt     DateTime          @default(now()) @map("created_at")
  updatedAt     DateTime          @updatedAt @map("updated_at")

  client      Profile?     @relation(fields: [clientId], references: [id])
  guestClient GuestClient? @relation(fields: [guestClientId], references: [id])
  barber      Barber       @relation(fields: [barberId], references: [id], onDelete: Restrict)
  service     Service      @relation(fields: [serviceId], references: [id], onDelete: Restrict)

  // IMPORTANT:
  // We intentionally do NOT keep a global UNIQUE constraint here, because cancelled
  // appointments must not permanently block the same slot from being rebooked.
  // Uniqueness for active bookings is enforced via a PARTIAL unique index in SQL
  // (status = 'CONFIRMED') plus an advisory-lock + overlap-check in `src/services/booking.ts`.
  @@index([barberId, date, startTime])
  @@map("appointments")
}

enum AppointmentStatus {
  CONFIRMED
  CANCELLED_BY_CLIENT
  CANCELLED_BY_BARBER
  COMPLETED
  NO_SHOW
}

model Notification {
  id        String           @id @default(uuid())
  userId    String           @map("user_id")
  type      NotificationType
  title     String
  message   String
  data      Json? // metadata adicional
  read      Boolean          @default(false)
  createdAt DateTime         @default(now()) @map("created_at")

  @@map("notifications")
}

enum NotificationType {
  APPOINTMENT_CONFIRMED
  APPOINTMENT_CANCELLED
  APPOINTMENT_REMINDER
}

// ============================================
// Barbershop Settings (singleton)
// ============================================

model BarbershopSettings {
  id          String  @id @default("default")
  
  // Business Identity
  name        String  @default("Gold Mustache Barbearia")
  shortName   String  @default("Gold Mustache") @map("short_name")
  tagline     String  @default("Tradição e Estilo Masculino")
  description String?
  
  // Address
  street       String @default("R. 115")
  number       String @default("79")
  neighborhood String @default("Centro")
  city         String @default("Itapema")
  state        String @default("SC")
  zipCode      String @default("88220-000") @map("zip_code")
  country      String @default("BR")
  
  // Coordinates
  latitude  Decimal @default(-27.0923025919406) @db.Decimal(10, 8)
  longitude Decimal @default(-48.611896766062245) @db.Decimal(11, 8)
  
  // Contact
  phone    String @default("47 98904-6178")
  whatsapp String @default("+5547989046178")
  email    String @default("contato@goldmustachebarbearia.com.br")
  
  // Social Media
  instagramMain  String  @default("@goldmustachebarbearia") @map("instagram_main")
  instagramStore String? @map("instagram_store")
  googleMapsUrl  String? @map("google_maps_url")
  
  // Booking
  bookingEnabled     Boolean @default(true) @map("booking_enabled")
  externalBookingUrl String? @map("external_booking_url")
  
  // Branding
  foundingYear Int @default(2018) @map("founding_year")
  
  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("barbershop_settings")
}

// ============================================
// LGPD Compliance - Cookie Consent Tracking
// ============================================

model CookieConsent {
  id               String   @id @default(uuid())
  userId           String?  @map("user_id") // For authenticated users
  anonymousId      String?  @map("anonymous_id") // For anonymous visitors
  analyticsConsent Boolean  @default(false) @map("analytics_consent")
  marketingConsent Boolean  @default(false) @map("marketing_consent")
  ipAddress        String?  @map("ip_address") @db.VarChar(45)
  userAgent        String?  @map("user_agent")
  consentDate      DateTime @default(now()) @map("consent_date")
  updatedAt        DateTime @updatedAt @map("updated_at")

  // Partial unique indexes are defined in the migration SQL
  // to allow multiple NULLs while preventing duplicates for non-null values
  @@map("cookie_consents")
}
